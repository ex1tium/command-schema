{
  "schema_version": "1.0.0",
  "command": "fgrep",
  "description": "GREP(1) User Commands GREP(1)",
  "global_flags": [
    {
      "short": "-A",
      "long": "--after-context",
      "value_type": "String",
      "takes_value": true,
      "description": "Places a line containing a group separator (--) between  contiguous  groups of matches.  With the -o or --only-matching option, this has no effect and a warning is given.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-G",
      "long": "--basic-regexp",
      "value_type": "String",
      "takes_value": true,
      "description": "This is the default.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-B",
      "long": "--before-context",
      "value_type": "String",
      "takes_value": true,
      "description": "NUM  lines of leading context before matching lines.  Places a line containing a group separator (--) between contiguous groups of matches.  With the -o or --only-matching option, this has no effect and a warning is given.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-U",
      "long": "--binary",
      "value_type": "File",
      "takes_value": true,
      "description": "By default, under MS-DOS and MS-Windows, grep guesses whether a file is text or binary as described  for the  --binary-files  option.  If grep decides the file is a text file, it strips the CR characters from the original file contents (to make regular expressions with ^ and $ work correctly).  Specifying -U overrules this guesswork, causing  all  files  to  be  read  and passed  to  the matching mechanism verbatim; if the file is a text file with CR/LF pairs at the end of each line, this will cause some regular expressions to fail.  This option has no effect on platforms other than MS-DOS and MS-Windows.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--binary-files",
      "value_type": "File",
      "takes_value": true,
      "description": "file  is  of  type  TYPE.   Non-text  bytes indicate  binary  data; these are either output bytes that are improperly encoded for the current locale, or null input bytes when the",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-b",
      "long": "--byte-offset",
      "value_type": "Bool",
      "takes_value": false,
      "description": "the  0-based  byte  offset  within  the input file before each line of output.  If -o (--only-matching) is specified, print the offset of the matching part itself.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--color",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--color[",
      "value_type": "File",
      "takes_value": true,
      "description": "the  matched (non-empty) strings, matching lines, context lines, file names, line numbers, byte offsets, and separators (for fields and groups of context lines) with escape sequences to display them in color on the terminal.  The colors  are  defined  by  the environment variable GREP_COLORS.  WHEN is never, always, or auto.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--colour",
      "value_type": "String",
      "takes_value": true,
      "description": "use markers to highlight the matching strings; WHEN is 'always', 'never', or 'auto'",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-C",
      "long": "--context",
      "value_type": "String",
      "takes_value": true,
      "description": "Places a line containing a group separator (--) between contiguous groups of matches.  With the -o or --only-matching option, this has no effect and a warning is given.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-c",
      "long": "--count",
      "value_type": "Bool",
      "takes_value": false,
      "description": "With the -v, --invert-match option (see  above), count non-matching lines.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-R",
      "long": "--dereference-recursive",
      "value_type": "Bool",
      "takes_value": false,
      "description": "Follow all symbolic links, unlike -r.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-D",
      "long": "--devices",
      "value_type": "File",
      "takes_value": true,
      "description": "By default, ACTION is read, which means that devices are read just as if they were ordinary files.  If ACTION is skip, devices are silently skipped.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-d",
      "long": "--directories",
      "value_type": "File",
      "takes_value": true,
      "description": "an  input  file is a directory, use ACTION to process it.  By default, ACTION is read, i.e., read directories just as if they were ordinary files.  If ACTION is skip, silently  skip  directories.   If  ACTION  is  recurse,  read  all  files  under  each  directory, recursively, following symbolic links only if they are on the command line.  This is equivalent to the -r option.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--exclude",
      "value_type": "File",
      "takes_value": true,
      "description": "any  command-line  file  with  a name suffix that matches the pattern GLOB, using wildcard matching; a name suffix is either the whole name, or a trailing part that starts with a non-slash character immediately after a slash  (/)  in  the  name.   When  searching recursively,  skip  any subfile whose base name matches GLOB; the base name is the part after the last slash.  A pattern can use *, ?, and [...] as wildcards, and \\ to quote a wildcard or backslash character literally.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--exclude-dir",
      "value_type": "Directory",
      "takes_value": true,
      "description": "When searching recursively, skip  any  subdirectory whose base name matches GLOB.  Ignore any redundant trailing slashes in GLOB.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--exclude-from",
      "value_type": "String",
      "takes_value": true,
      "description": "skip files that match any file pattern from FILE",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-E",
      "long": "--extended-regexp",
      "value_type": "String",
      "takes_value": true,
      "description": "PATTERNS are extended regular expressions",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-f",
      "long": "--file",
      "value_type": "File",
      "takes_value": true,
      "description": "patterns  from FILE, one per line.  If this option is used multiple times or is combined with the -e (--regexp) option, search for all patterns given.  The empty file contains zero patterns, and therefore matches nothing.  If FILE is  -  ,  read  patterns  from standard input.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-l",
      "long": "--files-with-matches",
      "value_type": "Bool",
      "takes_value": false,
      "description": "normal  output; instead print the name of each input file from which output would normally have been printed.  Scanning each input file stops upon first match.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-L",
      "long": "--files-without-match",
      "value_type": "Bool",
      "takes_value": false,
      "description": "print only names of FILEs with no selected lines",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-F",
      "long": "--fixed-strings",
      "value_type": "String",
      "takes_value": true,
      "description": "PATTERNS are strings",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--group-separator",
      "value_type": "String",
      "takes_value": true,
      "description": "print SEP on line between matches with context",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--help",
      "value_type": "Bool",
      "takes_value": false,
      "description": "display this help text and exit",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-i",
      "long": "--ignore-case",
      "value_type": "Bool",
      "takes_value": false,
      "description": "ignore case distinctions in patterns and data",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--include",
      "value_type": "String",
      "takes_value": true,
      "description": "If contradictory --include and",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-T",
      "long": "--initial-tab",
      "value_type": "Bool",
      "takes_value": false,
      "description": "sure  that  the  first character of actual line content lies on a tab stop, so that the alignment of tabs looks normal.  This is useful with options that prefix their output to the actual content: -H,-n, and -b.  In order to improve  the  probability  that  lines from a single file will all start at the same column, this also causes the line number and byte offset (if present) to be printed in a minimum size field width.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-v",
      "long": "--invert-match",
      "value_type": "Bool",
      "takes_value": false,
      "description": "select non-matching lines",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--label",
      "value_type": "File",
      "takes_value": true,
      "description": "This can be useful for commands that  transform  a file's contents before searching, e.g., gzip -cd foo.gz | grep --label=foo -H 'some pattern'.  See also the -H option.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--line-buffered",
      "value_type": "Bool",
      "takes_value": false,
      "description": "This can cause a performance penalty.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-n",
      "long": "--line-number",
      "value_type": "Bool",
      "takes_value": false,
      "description": "print line number with output lines",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-x",
      "long": "--line-regexp",
      "value_type": "Bool",
      "takes_value": false,
      "description": "only  those  matches  that  exactly  match  the whole line.  For a regular expression pattern, this is like parenthesizing the pattern and then surrounding it with ^ and $.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-m",
      "long": "--max-count",
      "value_type": "File",
      "takes_value": true,
      "description": "If NUM is zero, grep stops right away without reading input.  A NUM of -1 is treated as infinity and grep does not stop; this is the default.  If the input is standard input from a regular file, and NUM matching lines  are output,  grep  ensures  that  the  standard input is positioned to just after the last matching line before exiting, regardless of the presence of trailing context lines.  This enables a calling process to resume a search.  When grep stops after NUM matching lines,  it outputs  any trailing context lines.  When the -c or --count option is also used, grep does not output a count greater than NUM.  When the -v or --invert-match option is also used, grep stops after outputting NUM non-matching lines.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-h",
      "long": "--no-filename",
      "value_type": "Bool",
      "takes_value": false,
      "description": "This is the default when there is only one file (or only standard input) to search.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--no-group-separator",
      "value_type": "Bool",
      "takes_value": false,
      "description": "do not print separator for matches with context",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--no-ignore-case",
      "value_type": "Bool",
      "takes_value": false,
      "description": "not ignore case distinctions in patterns and input data.  This is the default.  This option is useful for passing to shell scripts that already use -i, to cancel its effects because the two options override each other.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-s",
      "long": "--no-messages",
      "value_type": "Bool",
      "takes_value": false,
      "description": "suppress error messages",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-Z",
      "long": "--null",
      "value_type": "File",
      "takes_value": true,
      "description": "a  zero  byte  (the  ASCII  NUL  character) instead of the character that normally follows a file name.  For example, grep -lZ outputs a zero byte after each file name instead of the usual newline.  This option makes the output unambiguous, even in the presence of file names containing unusual characters like newlines.  This option can be used with commands like find -print0, perl -0, sort -z, and xargs -0 to process arbitrary file names, even those that contain newline characters.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-z",
      "long": "--null-data",
      "value_type": "File",
      "takes_value": true,
      "description": "character)  instead  of  a  newline. Like the -Z or --null option, this option can be used with commands like sort -z to process arbitrary file names.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-o",
      "long": "--only-matching",
      "value_type": "Bool",
      "takes_value": false,
      "description": "show only nonempty parts of lines that match",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-P",
      "long": "--perl-regexp",
      "value_type": "String",
      "takes_value": true,
      "description": "PATTERNS  as  Perl-compatible  regular  expressions  (PCREs).   This  option  is  experimental  when  combined  with the -z (--null-data) option, and grep -P may warn of unimplemented features.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-q",
      "long": "--quiet",
      "value_type": "Bool",
      "takes_value": false,
      "description": "Exit immediately with zero status if any match  is  found,  even  if  an  error  was detected.  Also see the -s or --no-messages option.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-r",
      "long": "--recursive",
      "value_type": "Bool",
      "takes_value": false,
      "description": "Note that if no file operand is given, grep searches the working directory.  This is equivalent to the -d recurse option.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-e",
      "long": "--regexp",
      "value_type": "File",
      "takes_value": true,
      "description": "If this option is used multiple times or is combined with  the  -f  (--file)  option,  search  for  all patterns given.  This option can be used to protect a pattern beginning with “-”.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-a",
      "long": "--text",
      "value_type": "String",
      "takes_value": true,
      "description": "equivalent to --binary-files=text",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-V",
      "long": "--version",
      "value_type": "Bool",
      "takes_value": false,
      "description": "display version information and exit",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-H",
      "long": "--with-filename",
      "value_type": "File",
      "takes_value": true,
      "description": "This is the default when there is more than one file to search.  This is a GNU extension.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-w",
      "long": "--word-regexp",
      "value_type": "Bool",
      "takes_value": false,
      "description": "The test is that the matching  substring  must  either  be  at  the beginning  of  the  line,  or  preceded  by  a non-word constituent character.  Similarly, it must be either at the end of the line or followed by a non-word constituent character.  Word-constituent characters are letters, digits, and the underscore.  This  option  has no effect if -x is also specified.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-I",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "Process a binary file as if it did not contain matching data; this is equivalent to the --binary-files=without-match option.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-NUM",
      "long": null,
      "value_type": "Number",
      "takes_value": true,
      "description": "same as --context=NUM",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    }
  ],
  "subcommands": [],
  "positional": [
    {
      "name": "pattern_file",
      "value_type": "File",
      "required": true,
      "multiple": false,
      "description": null
    },
    {
      "name": "patterns",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    }
  ],
  "source": "Merged",
  "confidence": 0.9,
  "version": null
}