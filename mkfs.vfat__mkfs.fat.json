{
  "schema_version": "1.0.0",
  "command": "mkfs.vfat",
  "description": "MKFS.FAT(8) System Manager's Manual MKFS.FAT(8)",
  "global_flags": [
    {
      "short": null,
      "long": "--codepage",
      "value_type": "String",
      "takes_value": true,
      "description": "By default codepage 850 is used.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--help",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--invariant",
      "value_type": "String",
      "takes_value": true,
      "description": "Multiple runs of mkfs.fat  on  the same device create identical results with this option.  Its main purpose is testing mkfs.fat.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--mbr[",
      "value_type": "String",
      "takes_value": true,
      "description": "device.   It is  needed only for non-removable disks used on Microsoft Windows systems and only when formatting whole unpartitioned disk.  Location of the disk signature and partition table overlaps with the end of the first FAT sector (boot code location), therefore there  is  no  addi‐ tional  space  usage.   Default  is auto mode in which mkfs.fat put MBR table only for non-removable disks when formatting whole unparti‐ tioned disk.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--offset",
      "value_type": "File",
      "takes_value": true,
      "description": "the  filesystem  at  a specific sector into the device file.  This is useful for creating a filesystem in a partitioned disk image without having to set up a loop device.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--variant",
      "value_type": "String",
      "takes_value": true,
      "description": "Acceptable values are standard and atari (in any combination of upper/lower case).  See above under DESCRIPTION for the differences.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-A",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "Select  using  the Atari variation of the FAT filesystem if that isn't active already, otherwise select standard FAT filesystem.  This is selected by default if mkfs.fat is run on 68k Atari Linux.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-C",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "Create  the  file  given as DEVICE on the command line, and write the to-be-created filesystem to it.  This can be used to create the new filesystem in a file instead of on a real device, and to avoid using dd in advance to create a file of appropriate size.  With  this  op‐ tion,  the  BLOCK-COUNT  must  be  given, because otherwise the intended size of the filesystem wouldn't be known.  The file created is a sparse file, which actually only contains the meta-data areas (boot sector, FATs, and root directory).  The data portions won't be stored on the disk, but the file nevertheless will have the correct size.  The resulting file can be copied later to a floppy disk or other  de‐ vice, or mounted through a loop device.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-D",
      "long": null,
      "value_type": "Number",
      "takes_value": true,
      "description": "the BIOS drive number to be stored in the FAT boot sector.  For hard disks and removable medias it is usually 0x80–0xFF (0x80 is first hard disk C:, 0x81 is second hard disk D:, ...), for floppy devices or partitions to be used for floppy emulation it  is  0x00–0x7F (0x00 is first floppy A:, 0x01 is second floppy B:).",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-F",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "the  type  of file allocation tables used (12, 16 or 32 bit).  If nothing is specified, mkfs.fat will automatically select be‐ tween 12, 16 and 32 bit, whatever fits better for the filesystem size.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-I",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "Ignore  and  disable  safety  checks.  By default mkfs.fat refuses to create a filesystem on a device with partitions or virtual mapping. mkfs.fat will complain and tell you that it refuses to work.  This is different when using MO disks.  One doesn't always need  partitions on  MO  disks.  The filesystem can go directly to the whole disk.  Under other OSes this is known as the superfloppy format.  This switch will force mkfs.fat to work properly.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-M",
      "long": null,
      "value_type": "String",
      "takes_value": true,
      "description": "the  media type to be stored in the FAT boot sector.  This value is usually 0xF8 for hard disks and is 0xF0 or a value from 0xF9 to 0xFF for floppies or partitions to be used for floppy emulation.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-R",
      "long": null,
      "value_type": "Number",
      "takes_value": true,
      "description": "With FAT32 format at least 2 reserved sectors are needed, the default is  32.   Otherwise the default is 1 (only the boot sector).  Note that this is minimal number and it may be increased by mkfs.fat due to alignment of struc‐ tures.  See also mkfs.fat option -a.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-S",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "Must be a power of 2 and greater than or equal to 512, i.e. 512, 1024, 2048, 4096, 8192, 16384, or 32768.  Values larger than 4096 are not conforming to the FAT file system specification and may not work everywhere.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-a",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "Normally, for any filesystem except very small ones, mkfs.fat will align all the data structures to cluster size, to make  sure  that  as long  as  the partition is properly aligned, so will all the data structures in the filesystem.  This option disables alignment; this may provide a handful of additional clusters of storage at the expense of a significant performance degradation  on  RAIDs,  flash  media  or large-sector hard disks.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-b",
      "long": null,
      "value_type": "Number",
      "takes_value": true,
      "description": "Default depends on number of reserved sectors, but usually is  sector  6.   If there  is  a  free space available after the backup boot sector then backup of the FAT32 info sector is put after the backup boot sector, usually at sector 7.  The backup must be within the range of reserved sectors.  Value 0 completely disables creating of backup  boot  and info FAT32 sectors.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-c",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "Check the device for bad blocks before creating the filesystem.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-f",
      "long": null,
      "value_type": "String",
      "takes_value": true,
      "description": "The default is 2.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-g",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "Both numbers are stored into the FAT boot  sector. Number  SECTORS-PER-TRACK is used also for aligning the total count of FAT sectors.  By default disk geometry is read from DEVICE itself. If it is not available then LBA-Assist Translation and translation table from the SD Card Part 2 File System Specification based on total number of disk sectors is used.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-h",
      "long": null,
      "value_type": "String",
      "takes_value": true,
      "description": "Normally this is an offset (in sectors) relative to the start of the disk, although for  MBR  logical volumes  contained  in an extended partition of type 0x05 (a non-LBA extended partition), a quirk in the MS-DOS implementation of FAT re‐ quires it to be relative to the partition's immediate containing Extended Boot Record.  Boot code and other software handling FAT volumes may also rely on this field being set up correctly; most modern FAT implementations will ignore it.  By default, if the DEVICE is a  par‐ tition  block  device,  mkfs.fat uses the partition offset relative to disk start.  Otherwise, mkfs.fat assumes zero.  Use this option to override this behaviour.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-i",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "The default  is  a number which depends on the filesystem creation time.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-l",
      "long": null,
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-m",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "The  mes‐ sage file must not exceed 418 bytes once line feeds have been converted to carriage return-line feed combinations, and tabs have been ex‐ panded.  If the filename is a hyphen (-), the text is taken from standard input.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-n",
      "long": null,
      "value_type": "String",
      "takes_value": true,
      "description": "The volume name can be up to 11 characters long.  Supplying an empty  string,  a  string consisting only of white space or the string \"NO NAME\" as VOLUME-NAME has the same effect as not giving the -n option.  The default is no label.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-r",
      "long": null,
      "value_type": "Directory",
      "takes_value": true,
      "description": "the  minimal  number  of entries available in the root directory.  The default is 112 or 224 for floppies and 512 for hard disks. Note that this is minimal number and it may be increased by mkfs.fat due to alignment of structures.  See also mkfs.fat option -a.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-s",
      "long": null,
      "value_type": "String",
      "takes_value": true,
      "description": "Must be a power of 2, i.e. 1, 2, 4, 8, ... 128.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-v",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "Verbose execution.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    }
  ],
  "subcommands": [],
  "positional": [
    {
      "name": "block-count",
      "value_type": "Number",
      "required": false,
      "multiple": false,
      "description": null
    },
    {
      "name": "device",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    }
  ],
  "source": "ManPage",
  "confidence": 0.9,
  "version": null
}