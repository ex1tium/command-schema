{
  "schema_version": "1.0.0",
  "command": "zip",
  "description": "zip - package and compress (archive) files",
  "global_flags": [
    {
      "short": null,
      "long": "--DOS-names",
      "value_type": "File",
      "takes_value": true,
      "description": "paths  to  conform  to  MSDOS, store  only  the  MSDOS attribute (just the user write attribute from Unix), and mark the entry as made under MSDOS (even  though it  was  not);  for compatibility with PKUNZIP under MSDOS which cannot handle certain names such as those with two dots.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--Q-flag",
      "value_type": "File",
      "takes_value": true,
      "description": "store information about the file in the file header with n defined as bit  0: Don't add headers for any file bit  1: Add headers for all files bit  2: Don't wait for interactive key press on exit",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--VMS-dot-versions",
      "value_type": "File",
      "takes_value": true,
      "description": "the  name,  in‐ cluding  multiple versions of files, using the .nnn format.  De‐ fault is to use only the most  recent  version  of  a  specified file.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--VMS-portable",
      "value_type": "File",
      "takes_value": true,
      "description": "Save VMS file attributes.  (Files are  truncated at EOF.) When a -V archive is unpacked on a non-VMS  system,   some  file types  (notably  Stream_LF  text  files   and  pure binary files like fixed-512) should be extracted intact.  Indexed  files  and file  types  with embedded record sizes (notably variable-length record types) will probably be seen as corrupt elsewhere.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--VMS-specific",
      "value_type": "File",
      "takes_value": true,
      "description": "all allocated blocks  in  a file,   including  any  data beyond EOF.  Useful for moving ill- formed files  among  VMS systems.   When a -VV  archive  is  un‐ packed  on  a  non-VMS system, almost all files will appear cor‐ rupt.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--VMS-versions",
      "value_type": "File",
      "takes_value": true,
      "description": "the  name,  in‐ cluding  multiple versions of files.  Default is to use only the most recent version of a specified file.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--absolute-path",
      "value_type": "Bool",
      "takes_value": false,
      "description": "will  be  stored.  By  default the relative path will be stored.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--adjust-sfx",
      "value_type": "Number",
      "takes_value": true,
      "description": "self-extracting  executable  archive.  A self-extracting executable archive is created by prepending the SFX stub  to  an existing  archive.  The  -A option tells zip to adjust the entry offsets stored in the archive to take into account this  \"pream‐ ble\" data.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--archive-clear",
      "value_type": "Bool",
      "takes_value": false,
      "description": "Once archive is created (and  tested  if  -T  is  used, which   is   recommended),  clear  the  archive  bits  of  files processed.  WARNING: Once the bits are cleared they are cleared. You may want to use the -sf show files option to store the  list of  files  processed  in  case the archive operation must be re‐ peated.  Also consider using the -MM must match option.  Be sure to check out -DF as a possibly  better  way  to  do  incremental backups.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--archive-comment",
      "value_type": "File",
      "takes_value": true,
      "description": "The comment is ended by a line containing just a period, or  an  end of file condition (^D on Unix, ^Z on MSDOS, OS/2, and VMS).  The comment can be taken from a file:",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--archive-set",
      "value_type": "Bool",
      "takes_value": false,
      "description": "Only include files that have the archive bit set.  Di‐ rectories are not stored when -AS is used, though by default the paths of entries, including directories, are stored as usual and can be used by most unzips to recreate directories.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--ascii",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--before-date",
      "value_type": "String",
      "takes_value": true,
      "description": "mm  is  the  month  (00-12),  dd  is the day of the month (01-31), and  yyyy  is  the  year.   The  ISO 8601  date  format yyyy-mm-dd is also accepted.  For example:",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--binary",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--compression-method",
      "value_type": "Bool",
      "takes_value": false,
      "description": "the default compression method.  Currently the main methods supported by zip are store and deflate.  Compression method  can be set to:",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--copy-entries",
      "value_type": "Bool",
      "takes_value": false,
      "description": "entries  from  one archive to another.  Requires the --out option to  specify  a  different  output  file  than  the  input archive.  Copy mode is the reverse of -d delete.  When delete is being used with --out, the selected entries are deleted from the archive  and  all  other  entries are copied to the new archive, while copy mode selects the files to include in the new archive. Unlike -u update, input patterns on the command line are matched against archive entries only and not the file system files.  For instance,",
      "multiple": false,
      "conflicts_with": [],
      "requires": [
        "-d",
        "-u"
      ]
    },
    {
      "short": null,
      "long": "--datafork",
      "value_type": "Bool",
      "takes_value": false,
      "description": "for  exporting  files  to  foreign operating-systems.  Re‐ source-forks will be ignored at all.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--delete",
      "value_type": "Bool",
      "takes_value": false,
      "description": "For example:",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--difference-archive",
      "value_type": "Bool",
      "takes_value": false,
      "description": "since the  original  archive was created.  For this to work, the input file list and current directory must be the same as  during  the original zip operation.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--display-bytes",
      "value_type": "Bool",
      "takes_value": false,
      "description": "running  byte  counts  showing the bytes zipped and the bytes to go.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--display-counts",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--display-dots",
      "value_type": "File",
      "takes_value": true,
      "description": "on  ports  that have  their  own progress indicator).  See -ds below for setting dot size.  The default is a  dot  every  10  MB  of  input  file processed.   The  -v  option also displays dots (previously at a much higher rate than this but now -v also defaults  to  10  MB) and this rate is also controlled by -ds.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--display-globaldots",
      "value_type": "Bool",
      "takes_value": false,
      "description": "file. The command",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--display-usize",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--display-volume",
      "value_type": "Bool",
      "takes_value": false,
      "description": "the volume (disk) number each entry is being read from, if reading an existing archive, and being written to.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--dot-size",
      "value_type": "Bool",
      "takes_value": false,
      "description": "amount of input file processed for each dot displayed.  See",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--encrypt",
      "value_type": "Bool",
      "takes_value": false,
      "description": "password  which is  entered  on  the terminal in response to a prompt (this will not be echoed; if standard error is not a  tty,  zip  will  exit with  an  error).   The  password prompt is repeated to save the user from typing errors.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--entry-comments",
      "value_type": "Bool",
      "takes_value": false,
      "description": "File  operations  (adding, updating)  are  done  first, and the user is then prompted for a one-line comment for each file.  Enter the comment  followed  by return, or just return for no comment.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--exclude",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--fifo",
      "value_type": "Number",
      "takes_value": true,
      "description": "Normally zip skips reading any FIFOs (named  pipes)  en‐ countered,  as  zip can hang if the FIFO is not being fed.  This option tells zip to read the contents of any FIFO it finds.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--filesync",
      "value_type": "File",
      "takes_value": true,
      "description": "files  are  added  and changed  files are updated but files that no longer exist on the OS are not deleted from the archive.  This option enables a  new mode that checks entries in the archive against the file system. If  the file time and file size of the entry matches that of the OS file, the entry is copied from the old archive instead of be‐ ing read from the file system and compressed.  If  the  OS  file has  changed, the entry is read and compressed as usual.  If the entry in the archive does not match a file on the OS, the  entry is  deleted.   Enabling  this option should create archives that are the same as new archives, but  since  existing  entries  are copied  instead of compressed, updating an existing archive with",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--fix",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--fixfix",
      "value_type": "Bool",
      "takes_value": false,
      "description": "the zip archive. The -F option can be used if some portions of the archive are missing, but  requires  a  reasonably  intact central  directory.   The input archive is scanned as usual, but zip will ignore some problems.  The resulting archive should  be valid, but any inconsistent entries will be left out.",
      "multiple": false,
      "conflicts_with": [],
      "requires": [
        "-F"
      ]
    },
    {
      "short": null,
      "long": "--freshen",
      "value_type": "Bool",
      "takes_value": false,
      "description": "(freshen)  an existing entry in the zip archive only if it has been modified more recently than the version  already  in the zip archive; unlike the update option (-u) this will not add files that are not already in the zip archive.  For example:",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--from-crlf",
      "value_type": "File",
      "takes_value": true,
      "description": "This option should not be used on binary files.  This option can be used  on MSDOS  if the zip file is intended for unzip under Unix.  If the file is converted and the file is later determined to be  binary a warning is issued and the file is probably corrupted.  In this release  if  -ll  detects binary in the first buffer read from a file, zip now issues a warning and skips line end conversion  on the  file.   This  check seems to catch all binary files tested, but the original check remains and if a converted file is  later determined to be binary that warning is still issued.  A new al‐ gorithm is now being used for binary detection that should allow line  end  conversion  of text files in UTF-8 and similar encod‐ ings.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--from-date",
      "value_type": "String",
      "takes_value": true,
      "description": "the  specified  date, where  mm  is  the  month  (00-12),  dd  is the day of the month (01-31), and  yyyy  is  the  year.   The  ISO 8601  date  format yyyy-mm-dd is also accepted.  For example:",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--grow",
      "value_type": "Bool",
      "takes_value": false,
      "description": "creating a  new one. If this operation fails, zip attempts to restore the archive to its original state. If  the  restoration  fails,  the archive  might  become  corrupted.  This  option is ignored when there's no existing archive or when at least one archive  member must be updated or deleted.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--help",
      "value_type": "Bool",
      "takes_value": false,
      "description": "the  zip  help information (this also appears if zip is run with no arguments).",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--ignore-case",
      "value_type": "File",
      "takes_value": true,
      "description": "archive  entries.   This option  is  only available on systems where the case of files is ignored.  On systems with case-insensitive file systems, case is normally ignored when matching files on the file system  but  is not  ignored for -f (freshen), -d (delete), -U (copy), and simi‐ lar modes when matching against archive  entries  (currently  -f ignores case on VMS) because archive entries can be from systems where  case  does  matter and names that are the same except for case can exist in an archive.  The -ic option makes all matching case insensitive.  This can result in multiple  archive  entries matching a command line pattern.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--include",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--junk-paths",
      "value_type": "Bool",
      "takes_value": false,
      "description": "just the name of a saved file (junk the path), and do not store directory names. By default, zip will store the full  path (relative to the current directory).",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--junk-sfx",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--latest-time",
      "value_type": "Bool",
      "takes_value": false,
      "description": "to  the  latest (oldest) \"last modified\" time found among the entries in the zip archive.   This can be used without any other operations, if de‐ sired.  For example:",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--license",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--log-append",
      "value_type": "Bool",
      "takes_value": false,
      "description": "Default is to overwrite.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--log-info",
      "value_type": "Bool",
      "takes_value": false,
      "description": "being  zipped, in  the  log.   The default is to only include the command line, any warnings and errors, and the final status.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--logfile-path",
      "value_type": "Bool",
      "takes_value": false,
      "description": "a logfile at the given path.  By default any existing file at that location is overwritten, but the -la option will  result in an existing file being opened and the new log information ap‐ pended  to  any  existing information.  Only warnings and errors are written to the log unless the -li option is also given, then all information messages are also written to the log.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--longnames",
      "value_type": "Bool",
      "takes_value": false,
      "description": "file‐ name.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--longoption",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--more-help",
      "value_type": "Bool",
      "takes_value": false,
      "description": "on  command  line  format, pattern matching, and more obscure options.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--move",
      "value_type": "Bool",
      "takes_value": false,
      "description": "archive;  actually,  this deletes  the target directories/files after making the specified zip archive. If a directory becomes empty after removal  of  the files,  the directory is also removed. No deletions are done un‐ til zip has created the archive without error.  This  is  useful for conserving disk space, but is potentially dangerous so it is recommended to use it in combination with -T to test the archive before removing all input files.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--must-match",
      "value_type": "File",
      "takes_value": true,
      "description": "input  patterns  must match at least one file and all input files found must be readable.  Normally when  an  input  pattern does  not  match a file the \"name not matched\" warning is issued and when an input file has been found but later  is  missing  or not  readable  a  missing or not readable warning is issued.  In either case zip continues creating the archive, with missing  or unreadable  new  files  being  skipped  and files already in the archive remaining unchanged.  After the archive is  created,  if any  files were not readable zip returns the OPEN error code (18 on most systems) instead of the normal success return (0 on most systems).  With -MM set, zip exits as soon as an  input  pattern is not matched (whenever the \"name not matched\" warning would be issued)  or  when an input file is not readable.  In either case zip exits with an OPEN error and no archive is created.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--names-stdin",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--no-dir-entries",
      "value_type": "Directory",
      "takes_value": true,
      "description": "directories.   Di‐ rectory  entries are created by default so that their attributes can be saved in  the  zip  archive.   The  environment  variable ZIPOPT  can  be  used to change the default options. For example under Unix with sh:",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--no-extra",
      "value_type": "Bool",
      "takes_value": false,
      "description": "not save extra file attributes (Extended Attributes on OS/2, uid/gid and file times on Unix).   The  zip  format  uses  extra fields  to  include additional information for each entry.  Some extra fields are specific to particular systems while others are applicable to all systems.  Normally when zip reads entries from an existing archive, it reads the extra fields it knows,  strips the  rest,  and adds the extra fields applicable to that system. With -X, zip strips all old fields and only includes the Unicode and Zip64 extra fields (currently these two extra fields  cannot be disabled).",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--no-image",
      "value_type": "File",
      "takes_value": true,
      "description": "RISC OS] Don't scan through Image files.  When used, zip will not consider Image  files  (eg.  DOS  partitions  or  Spark archives  when  SparkFS is loaded) as directories but will store them as single files.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--no-wild",
      "value_type": "Bool",
      "takes_value": false,
      "description": "is  still  done by the shell unless the arguments are escaped).  Useful if a list of paths is being read and no  wild‐ card substitution is desired.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--notes",
      "value_type": "Bool",
      "takes_value": false,
      "description": "MacOS]  Save  Amiga  or MacOS filenotes as zipfile com‐ ments. They can be restored by using the -N option of unzip.  If",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--output-file",
      "value_type": "Bool",
      "takes_value": false,
      "description": "instead  of  updating the  existing  archive,  output  the new archive to output-file. Useful for updating an archive  without  changing  the  existing archive  and the input archive must be a different file than the output archive.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--password",
      "value_type": "File",
      "takes_value": true,
      "description": "THIS IS INSE‐ CURE!  Many multi-user operating systems provide  ways  for  any user  to see the current command line of any other user; even on stand-alone systems there is  always  the  threat  of  over-the- shoulder  peeking.   Storing the plaintext password as part of a command line in an automated script  is  even  worse.   Whenever possible, use the non-echoing, interactive prompt to enter pass‐ words.   (And  where security is truly important, use strong en‐ cryption such as Pretty Good Privacy instead of  the  relatively weak standard encryption provided by zipfile utilities.)",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--paths",
      "value_type": "Bool",
      "takes_value": false,
      "description": "the  archive.  This is the default.  The -j option junks the paths and just stores the names of the files.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--preserve-case",
      "value_type": "String",
      "takes_value": true,
      "description": "Preserve  case  all  on VMS.  Negating this option (-C-) downcases.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--preserve-case-2",
      "value_type": "String",
      "takes_value": true,
      "description": "Preserve case ODS2 on VMS.  Negating this  option  (-C2-) downcases.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--preserve-case-5",
      "value_type": "String",
      "takes_value": true,
      "description": "Preserve  case ODS5 on VMS.  Negating this option (-C5-) downcases.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--quiet",
      "value_type": "Bool",
      "takes_value": false,
      "description": "mode;   eliminate  informational  messages  and  comment prompts.  (Useful, for example, in shell scripts and  background tasks).",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--recurse-paths",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--recurse-patterns",
      "value_type": "Bool",
      "takes_value": false,
      "description": "cur‐ rent directory; for example:",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--regex",
      "value_type": "Bool",
      "takes_value": false,
      "description": "Before zip 3.0, regular expression  list  matching  was enabled  by  default on Windows platforms.  Because of confusion resulting from the need to escape \"[\" and \"]\" in  names,  it  is now  off  by  default for Windows so \"[\" and \"]\" are just normal characters in names.  This option enables [] matching again.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--show-command",
      "value_type": "String",
      "takes_value": true,
      "description": "exit.   The new  command  parser permutes the arguments, putting all options and any values associated with them before any non-option  argu‐ ments.   This allows an option to appear anywhere in the command line as long as any values that go with the option go  with  it. This  option displays the command line as zip sees it, including any arguments from the environment such as from the ZIPOPT vari‐ able.  Where allowed, options later  in  the  command  line  can override options earlier in the command line.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--show-files",
      "value_type": "Bool",
      "takes_value": false,
      "description": "the  files  that would be operated on, then exit.  For in‐ stance, if creating a new archive, this will list the files that would be added.  If the option is negated, -sf-, output only  to an  open  log file.  Screen display is not recommended for large lists.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-sf",
      "long": "--show-just-unicode",
      "value_type": "Bool",
      "takes_value": false,
      "description": "the  path  if  exists, otherwise show the standard version of the path.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--show-options",
      "value_type": "Bool",
      "takes_value": false,
      "description": "on  the current  system.   As  this  command  reads the option table, it should include all options.  Each line includes the short option (if defined), the long option (if defined), the  format  of  any value  that  goes with the option, if the option can be negated, and a small description.  The value format can be no value,  re‐ quired  value,  optional  value,  single character value, number value, or a list of values.  The output of this  option  is  not intended  to  show  how to use any option but only show what op‐ tions are available.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--split-bell",
      "value_type": "Bool",
      "takes_value": false,
      "description": "splitting and using split pause mode, ring the bell when zip pauses for each split destination.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-s",
      "long": "--split-pause",
      "value_type": "Bool",
      "takes_value": false,
      "description": "This creates split archives as -s does, but stream writing is used so each  split  can be closed as soon as it is written and zip will pause between each split to allow changing split destination  or media.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--split-size",
      "value_type": "Bool",
      "takes_value": false,
      "description": "A split archive is an archive that could be split over many  files.   As the  archive  is created, if the size of the archive reaches the specified split size, that split is closed and  the  next  split opened.   In  general  all splits but the last will be the split size and the last will be  whatever  is  left.   If  the  entire archive  is smaller than the split size a single-file archive is created.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--split-verbose",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--suffixes",
      "value_type": "Bool",
      "takes_value": false,
      "description": "suffixes. Such  files are simply stored (0% compression) in the output zip file, so that zip doesn't waste  its  time  trying  to  compress them.   The  suffixes  are  separated  by either colons or semi‐ colons.  For example:",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--symlinks",
      "value_type": "File",
      "takes_value": true,
      "description": "such in  the zip archive, instead of compressing and storing the file referred to by the link.  This  can  avoid  multiple  copies  of files  being  included in the archive as zip recurses the direc‐ tory trees and accesses files directly and by links.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--system-hidden",
      "value_type": "File",
      "takes_value": true,
      "description": "Includes finder invisible files, which are ignored oth‐ erwise.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--temp-path",
      "value_type": "Bool",
      "takes_value": false,
      "description": "exam‐ ple:",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--test",
      "value_type": "Bool",
      "takes_value": false,
      "description": "the integrity of the new zip file. If the check fails, the old zip file is unchanged and (with  the  -m  option)  no  input files are removed.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--to-crlf",
      "value_type": "File",
      "takes_value": true,
      "description": "con‐ vention  CR  LF. This option should not be used on binary files. This option can be used on Unix if the zip file is intended  for PKUNZIP  under  MSDOS. If the input files already contain CR LF, this option adds an extra CR. This is to ensure that unzip -a on Unix will get back an exact copy of the original file,  to  undo the effect of zip -l.  See -ll for how binary files are handled.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--unicode",
      "value_type": "Bool",
      "takes_value": false,
      "description": "zip 3.0, in  addition  to  the standard file path, now includes the UTF-8 translation of the path if the entry path is not entirely  7-bit ASCII.   When  an entry is missing the Unicode path, zip reverts back to the standard file path.   The  problem  with  using  the standard  path is this path is in the local character set of the zip that created the entry, which may  contain  characters  that are  not  valid  in  the  character set being used by the unzip. When zip is reading an archive, if an entry also has  a  Unicode path, zip now defaults to using the Unicode path to recreate the standard path using the current local character set.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--unzip-command",
      "value_type": "Bool",
      "takes_value": false,
      "description": "command cmd instead of 'unzip -tqq' to test an archive when the -T option is used.  On Unix, to use a copy of unzip  in  the current  directory  instead  of the standard system unzip, could use:",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--update",
      "value_type": "Bool",
      "takes_value": false,
      "description": "the zip archive.  For example:",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--use-privileges",
      "value_type": "Bool",
      "takes_value": false,
      "description": "Use  privileges  (if  granted) to obtain all aspects of WinNT security.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--verbose",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--volume-label",
      "value_type": "File",
      "takes_value": true,
      "description": "volume  label  for  the  drive holding the first file to be compressed.  If you want to include only  the  volume  label  or  to force a specific drive, use the drive name as first file name, as in:",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--wild-stop-dirs",
      "value_type": "Bool",
      "takes_value": false,
      "description": "Normally zip handles paths as strings and given the paths",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-0",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "the  speed of compression using the specified digit #, where -0 indicates no compression (store all  files),  -1  indi‐ cates  the  fastest  compression speed (less compression) and -9 indicates the slowest compression  speed  (optimal  compression, ignores the suffix list). The default compression level is -6.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-1",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "compress faster",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-9",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "compress better",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-?",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-@",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "read names from stdin",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-A",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "adjust self-extracting exe",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-AC",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-AS",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-B",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-Bn",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "[TANDEM] set Edit/Enscribe formatting options with n defined as bit  0: Don't add delimiter (Edit/Enscribe) bit  1: Use LF rather than CR/LF as delimiter (Edit/Enscribe) bit  2: Space fill record to maximum record length (Enscribe) bit  3: Trim trailing space (Enscribe) bit  8: Force 30K (Expand) large read for unstructured files",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-C",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-C2",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-C5",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-D",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-DF",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-E",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-F",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "fix zipfile (-FF try harder) -D do not add directory entries",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-FF",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-FI",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-FS",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-I",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-J",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "junk zipfile prefix (unzipsfx)",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-L",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-MM",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-N",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-O",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-P",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-Qn",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-R",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-RE",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-S",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-T",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "test zipfile integrity",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-TT",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-U",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-UN",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-V",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-VV",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-X",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "eXclude eXtra file attributes",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-Z",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-a",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-aABcdDeEfFghjklLmoqrRSTuvVwXyz!@$",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-b",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-c",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "add one-line comments",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-d",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "delete entries in zipfile",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-db",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-dc",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-dd",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-df",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-dg",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-ds",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-du",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-dv",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-e",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "encrypt",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-f",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "freshen: only changed files",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-g",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-h",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-h2",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "show more help",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-i",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "include only the following names",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-ic",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-ifile",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "format  can  cause  problems if the first letter of file combines with i to form a two-letter  option  starting  with  i. Use -sc to see how your command line will be parsed.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-j",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "junk (don't record) directory names",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-jj",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-k",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-l",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "convert LF to CR LF (-ll CR LF to LF)",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-la",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-lf",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-li",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-ll",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-m",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "move into zipfile (delete OS files)",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-n",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "don't compress these suffixes",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-nw",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-o",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "make zipfile as old as latest entry",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-p",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-q",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "quiet operation",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-r",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "recurse into directories",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-sU",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-sb",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-sc",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-so",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-sp",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-su",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-sv",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-t",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-tt",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-u",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "update: only changed or new files",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-v",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "verbose operation/print version info",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-w",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-ws",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-ww",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-x",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "exclude the following names",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-y",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "store symbolic links as the link instead of the referenced file",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-z",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "add zipfile comment",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    }
  ],
  "subcommands": [
    {
      "name": "archives",
      "description": "that are readable by any unzip that supports split",
      "flags": [],
      "positional": [],
      "subcommands": [],
      "aliases": []
    },
    {
      "name": "can",
      "description": "be used to ring the bell when zip pauses for the next split destination.",
      "flags": [],
      "positional": [],
      "subcommands": [],
      "aliases": []
    },
    {
      "name": "for",
      "description": "how a split archive can be updated as it is copied to a new",
      "flags": [],
      "positional": [],
      "subcommands": [],
      "aliases": []
    },
    {
      "name": "split",
      "description": "mode updates the splits as the archive is being created,",
      "flags": [],
      "positional": [],
      "subcommands": [],
      "aliases": []
    }
  ],
  "positional": [
    {
      "name": "zipfile",
      "value_type": "File",
      "required": false,
      "multiple": false,
      "description": null
    }
  ],
  "source": "Merged",
  "confidence": 1.0,
  "version": "3.0"
}