//! Build script for `command-schema-db`.
//!
//! When the `bundled-schemas` feature is enabled, this script:
//! 1. Scans `schemas/database/` for JSON schema files.
//! 2. Compresses each file with gzip.
//! 3. Generates `src/bundled.rs` with `include_bytes!()` references.

use std::fs;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-env-changed=CARGO_FEATURE_BUNDLED_SCHEMAS");

    // Only generate bundled code when the feature is enabled.
    if std::env::var("CARGO_FEATURE_BUNDLED_SCHEMAS").is_err() {
        return;
    }

    // Locate the schema directory relative to the workspace root.
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
    let workspace_root = Path::new(&manifest_dir).parent().unwrap();
    let schema_dir = workspace_root.join("schemas").join("database");

    println!("cargo:rerun-if-changed={}", schema_dir.display());

    // Prepare output directory for compressed files.
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let bundled_dir = Path::new(&out_dir).join("bundled");
    fs::create_dir_all(&bundled_dir).unwrap();

    // Collect schema files and track compression statistics.
    let mut entries: Vec<(String, String)> = Vec::new(); // (command_name, compressed_path)
    let mut total_raw_bytes: u64 = 0;
    let mut total_compressed_bytes: u64 = 0;

    if schema_dir.is_dir() {
        if let Ok(read_dir) = fs::read_dir(&schema_dir) {
            for entry in read_dir.flatten() {
                let path = entry.path();
                if path.extension().and_then(|e| e.to_str()) == Some("json") {
                    let stem = path
                        .file_stem()
                        .and_then(|s| s.to_str())
                        .unwrap()
                        .to_string();

                    // Skip non-schema JSON files (e.g. manifest.json, extraction-report.json).
                    if stem == "manifest" || stem.starts_with("extraction-report") {
                        continue;
                    }

                    let raw = fs::read(&path).unwrap();
                    total_raw_bytes += raw.len() as u64;

                    // Compress with flate2.
                    use flate2::Compression;
                    use flate2::write::GzEncoder;
                    use std::io::Write;

                    let mut encoder = GzEncoder::new(Vec::new(), Compression::default());
                    encoder.write_all(&raw).unwrap();
                    let compressed = encoder.finish().unwrap();
                    total_compressed_bytes += compressed.len() as u64;

                    let gz_path = bundled_dir.join(format!("{stem}.json.gz"));
                    fs::write(&gz_path, &compressed).unwrap();

                    entries.push((stem, gz_path.display().to_string()));
                }
            }
        }
    } else {
        eprintln!(
            "cargo:warning=Schema directory not found at {}; bundled schemas will be empty.",
            schema_dir.display()
        );
    }

    // Print compression statistics for developer visibility.
    let schema_count = entries.len();
    let raw_kb = total_raw_bytes as f64 / 1024.0;
    let compressed_kb = total_compressed_bytes as f64 / 1024.0;
    let ratio = if total_raw_bytes > 0 {
        (1.0 - (total_compressed_bytes as f64 / total_raw_bytes as f64)) * 100.0
    } else {
        0.0
    };
    println!(
        "cargo:warning=Bundled schemas: {schema_count} schemas, {raw_kb:.1} KB raw -> {compressed_kb:.1} KB compressed ({ratio:.1}% reduction)"
    );

    entries.sort_by(|a, b| a.0.cmp(&b.0));

    // Generate bundled.rs into OUT_DIR (not src/) so builds don't dirty the tree.
    let bundled_rs = Path::new(&out_dir).join("bundled.rs");

    let mut code = String::new();
    code.push_str("// Auto-generated by build.rs â€” do not edit manually.\n");
    code.push_str("// Regenerate by building with the `bundled-schemas` feature.\n\n");
    code.push_str(
        "// Build-time embedded schemas with gzip compression.\n\
         //\n\
         // This module is auto-generated by `build.rs`. When the `bundled-schemas`\n\
         // feature is enabled, schema JSON files from `schemas/database/` are\n\
         // compressed at build time and embedded into the binary.\n\n",
    );

    code.push_str("/// Embedded compressed schemas generated by `build.rs`.\n");
    code.push_str("///\n");
    code.push_str("/// Each entry is `(command_name, gzip_compressed_json_bytes)`.\n");
    code.push_str("pub const BUNDLED_SCHEMAS: &[(&str, &[u8])] = &[\n");
    for (name, path) in &entries {
        // Normalize path separators for include_bytes! string literal
        // (Windows backslashes must be escaped or replaced with forward slashes)
        let safe_path = path.replace('\\', "/");
        code.push_str(&format!(
            "    (\"{name}\", include_bytes!(\"{safe_path}\")),\n"
        ));
    }
    code.push_str("];\n\n");

    code.push_str(
        "/// Decompresses and parses all bundled schemas.\n\
         ///\n\
         /// # Errors\n\
         ///\n\
         /// Returns [`DatabaseError::CompressionError`](crate::DatabaseError::CompressionError)\n\
         /// if decompression fails, or\n\
         /// [`DatabaseError::JsonError`](crate::DatabaseError::JsonError)\n\
         /// if the decompressed data is not valid schema JSON.\n\
         pub fn load_bundled_schemas() -> crate::error::Result<Vec<command_schema_core::CommandSchema>> {\n\
         \x20   use flate2::read::GzDecoder;\n\
         \x20   use std::io::Read;\n\
         \n\
         \x20   let mut schemas = Vec::with_capacity(BUNDLED_SCHEMAS.len());\n\
         \n\
         \x20   for (name, compressed) in BUNDLED_SCHEMAS {\n\
         \x20       let mut decoder = GzDecoder::new(*compressed);\n\
         \x20       let mut json = String::new();\n\
         \x20       decoder.read_to_string(&mut json).map_err(|e| {\n\
         \x20           crate::DatabaseError::CompressionError(format!(\n\
         \x20               \"failed to decompress schema for {name}: {e}\"\n\
         \x20           ))\n\
         \x20       })?;\n\
         \n\
         \x20       let schema: command_schema_core::CommandSchema = serde_json::from_str(&json)?;\n\
         \x20       schemas.push(schema);\n\
         \x20   }\n\
         \n\
         \x20   Ok(schemas)\n\
         }\n\n",
    );

    code.push_str("#[cfg(test)]\n");
    code.push_str("mod tests {\n");
    code.push_str("    use super::*;\n\n");
    code.push_str("    #[test]\n");
    code.push_str("    fn test_load_bundled() {\n");
    code.push_str("        let schemas = load_bundled_schemas().unwrap();\n");
    code.push_str(&format!(
        "        assert_eq!(schemas.len(), {});\n",
        entries.len()
    ));
    code.push_str("    }\n\n");
    code.push_str("    #[test]\n");
    code.push_str("    fn test_compression_roundtrip() {\n");
    code.push_str("        use flate2::read::GzDecoder;\n");
    code.push_str("        use flate2::write::GzEncoder;\n");
    code.push_str("        use flate2::Compression;\n");
    code.push_str("        use std::io::{Read, Write};\n\n");
    code.push_str("        let schema = command_schema_core::CommandSchema::new(\n");
    code.push_str("            \"test-cmd\",\n");
    code.push_str("            command_schema_core::SchemaSource::Bootstrap,\n");
    code.push_str("        );\n");
    code.push_str("        let json = serde_json::to_string(&schema).unwrap();\n\n");
    code.push_str(
        "        let mut encoder = GzEncoder::new(Vec::new(), Compression::default());\n",
    );
    code.push_str("        encoder.write_all(json.as_bytes()).unwrap();\n");
    code.push_str("        let compressed = encoder.finish().unwrap();\n\n");
    code.push_str("        let mut decoder = GzDecoder::new(compressed.as_slice());\n");
    code.push_str("        let mut decompressed = String::new();\n");
    code.push_str("        decoder.read_to_string(&mut decompressed).unwrap();\n\n");
    code.push_str("        let parsed: command_schema_core::CommandSchema =\n");
    code.push_str("            serde_json::from_str(&decompressed).unwrap();\n");
    code.push_str("        assert_eq!(parsed.command, \"test-cmd\");\n");
    code.push_str("    }\n");
    code.push_str("}\n");

    fs::write(&bundled_rs, &code).unwrap();
}
