{
  "schema_version": "1.0.0",
  "command": "llvm-exegesis-18",
  "description": "llvm-exegesis - LLVM Machine Instruction Benchmark",
  "global_flags": [
    {
      "short": null,
      "long": "--analysis-clustering",
      "value_type": "File",
      "takes_value": true,
      "description": "Naive clustering algorithm is better for doing further work on  the  -analysis-inconsistencies-output-file=  output,  it will create one cluster per opcode, and check that the cluster is stable (all points are neighbours).",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-clustering-epsilon",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-clusters-output-file",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-display-unstable-clusters",
      "value_type": "Bool",
      "takes_value": false,
      "description": "there  is more than one benchmark for an opcode, said benchmarks may end up not being clustered into the same cluster if the mea‐ sured performance characteristics are different. by default all such opcodes are filtered out.  This flag will instead show only such unstable opcodes.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-filter",
      "value_type": "String",
      "takes_value": true,
      "description": "default,  all benchmark results are analysed, but sometimes it may be useful to only look at those that to not involve memory, or vice versa. This option allows to either keep all benchmarks, or filter out (ignore) either all the ones that do involve memory  (in‐ volve instructions that may read or write to memory), or the opposite, to only keep such benchmarks.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-inconsistencies-output-file",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-inconsistency-epsilon",
      "value_type": "File",
      "takes_value": true,
      "description": "schedule  profile  values  (analysis mode).",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-numpoints",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-override-benchmark-triple-and-cpu",
      "value_type": "Bool",
      "takes_value": false,
      "description": "default, llvm-exegesis will analyze the benchmarks for the triple/CPU they were measured for, but if you want to analyze them for some other combination (specified via -mtriple/-mcpu), you can pass this flag.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-mode",
      "long": "--benchmark-phase",
      "value_type": "File",
      "takes_value": true,
      "description": "running  on the  hardware  for  which  the snippet was generated, and that supports performance measurements.  However, it is possible to stop at some stage before measuring. Choices are: * prepare-snippet: Only generate the minimal instruction  sequence.   *  prepare-and-assem‐ ble-snippet:  Same  as  prepare-snippet,  but also dumps an excerpt of the sequence (hex encoded).  * assemble-measured-code: Same as prepare-and-assemble-snippet. but also creates the full sequence that can be dumped to a file using  --dump-object-to-disk.   *  mea‐ sure: Same as assemble-measured-code, but also runs the measurement.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--benchmark-repeat-count",
      "value_type": "String",
      "takes_value": true,
      "description": "measurement  when  performing  latency  measurements.  By  default, llvm-exegesis will repeat a latency measurement enough times to balance run-time and noise reduction.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--benchmarks-file",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--dump-object-to-disk",
      "value_type": "File",
      "takes_value": true,
      "description": "llvm-exegesis will dump the generated code to a temporary file to enable code inspection. Disabled by default.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--execution-mode",
      "value_type": "String",
      "takes_value": true,
      "description": "option  specifies what execution mode to use. The inprocess execution mode is the default. The subprocess execution mode allows for additional features such as memory annotations but is currently restricted to X86-64 on Linux.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--help",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--help-list",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--ignore-invalid-sched-class",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--loop-body-size",
      "value_type": "Directory",
      "takes_value": true,
      "description": "Instead of looping over the snippet directly, first duplicate it so  that  the  loop body  contains  at least this many instructions. This potentially results in loop body being cached in the CPU Op Cache / Loop Cache, which allows to which may have higher throughput than the CPU decoders.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--max-configs-per-opcode",
      "value_type": "String",
      "takes_value": true,
      "description": "By default this is 1, meaning that we assume that a single measurement is enough to characterize an opcode. This might not be true of all instructions: for example, the performance  character‐ istics  of  the  LEA  instruction  on  X86  depends  on  the value of assigned registers and immediates. Setting a value of -max-con‐ figs-per-opcode larger than 1 allows llvm-exegesis to explore more configurations to discover if some register or  immediate  assign‐ ments lead to different performance characteristics.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--mcpu",
      "value_type": "String",
      "takes_value": true,
      "description": "CPU is unknown to LLVM).  (-mcpu=help for details)",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--measurements-print-progress",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--mode",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-version",
      "long": "--mtriple",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--num-repetitions",
      "value_type": "Number",
      "takes_value": true,
      "description": "the  target  number  of  executed  instructions.  Note  that  the actual repetition count of the snippet will be num-repeti‐ tions/snippet size.  Higher values lead to more accurate measurements but lengthen the benchmark.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--opcode-index",
      "value_type": "File",
      "takes_value": true,
      "description": "the  opcode  to  measure, by index. Specifying -1 will result in measuring every existing opcode. See example 1 for details. Either opcode-index, opcode-name or snippets-file must be set.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--opcode-name",
      "value_type": "File",
      "takes_value": true,
      "description": "details.   Ei‐ ther opcode-index, opcode-name or snippets-file must be set.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--repetition-mode",
      "value_type": "Number",
      "takes_value": true,
      "description": "num-repetitions  instructions  (repeating the  snippet  num-repetitions/snippet size times). loop will, optionally, duplicate the snippet until the loop body contains at least loop-body-size instructions, and then wrap the result in a loop which will execute num-repetitions instructions (thus, again, repeat‐ ing the snippet num-repetitions/snippet size times). The loop mode, especially with loop unrolling tends to better hide  the  effects of  the CPU frontend on architectures that cache decoded instructions, but consumes a register for counting iterations. If performing an analysis over many opcodes, it may be best to instead use the min mode, which will run each other mode, and  produce  the  minimal measured result.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--result-aggregation-mode",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--snippets-file",
      "value_type": "File",
      "takes_value": true,
      "description": "the  custom  code  snippet to measure. See example 2 for details.  Either opcode-index, opcode-name or snippets-file must be set.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--use-dummy-perf-counters",
      "value_type": "Bool",
      "takes_value": false,
      "description": "be  used  to  ensure  a snippet doesn't crash when hardware performance counters are unavailable and for debugging llvm-exegesis itself.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--validation-counter",
      "value_type": "Number",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--version",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--x86-disable-upper-sse-registers",
      "value_type": "Bool",
      "takes_value": false,
      "description": "the upper xmm registers (xmm8-xmm15) forces a longer instruction encoding which may put greater pressure on the frontend fetch and decode stages, potentially reducing the rate that instructions are dispatched to the backend,  particularly  on  older  hardware. Comparing  baseline  results with this mode enabled can help determine the effects of the frontend and can be used to improve latency and throughput estimates.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--x86-lbr-sample-period",
      "value_type": "Number",
      "takes_value": true,
      "description": "the LBR sampling period - how many branches before we take a sample.  When a positive value is specified for this option and when the mode is latency, we will use LBRs for measuring.  On choosing the \"right\" sampling period, a small value is  preferred,  but throttling could occur if the sampling is too frequent. A prime number should be used to avoid consistently skipping certain blocks.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    }
  ],
  "subcommands": [],
  "positional": [
    {
      "name": "ANALYSIS",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    },
    {
      "name": "ANNOTATIONS",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    },
    {
      "name": "BENCHMARKING",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    },
    {
      "name": "EXAMPLE",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    },
    {
      "name": "EXIT",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    },
    {
      "name": "INSTRUCTIONS",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    },
    {
      "name": "LBR.",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    },
    {
      "name": "PLATFORMS",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    },
    {
      "name": "RDTSC",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    },
    {
      "name": "SNIPPET",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    },
    {
      "name": "STATUS",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    },
    {
      "name": "SUPPORTED",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    },
    {
      "name": "X86",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    },
    {
      "name": "x86-lbr-sample-period",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    }
  ],
  "source": "Merged",
  "confidence": 0.9,
  "version": null
}