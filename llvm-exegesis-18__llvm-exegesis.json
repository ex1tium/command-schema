{
  "schema_version": "1.0.0",
  "command": "llvm-exegesis-18",
  "description": "llvm-exegesis - LLVM Machine Instruction Benchmark",
  "global_flags": [
    {
      "short": null,
      "long": "--analysis-clustering",
      "value_type": "File",
      "takes_value": true,
      "description": "the clustering algorithm to use. By default DBSCAN will be used.  Naive clustering algorithm is better for doing further work on the  -analysis-inconsistencies-output-file=  output,  it will  create  one cluster per opcode, and check that the cluster is stable (all points are neighbours).",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-clustering-epsilon",
      "value_type": "String",
      "takes_value": true,
      "description": "the  epsilon parameter used for clustering of benchmark points (analysis mode).",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-clusters-output-file",
      "value_type": "File",
      "takes_value": true,
      "description": "provided,  write  the analysis clusters as CSV to this file. \"-\" prints to stdout. By default, this analysis is not run.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-display-unstable-clusters",
      "value_type": "Bool",
      "takes_value": false,
      "description": "said  bench‐ marks  may  end  up not being clustered into the same cluster if the measured performance characteristics are different.  by  de‐ fault all such opcodes are filtered out.  This flag will instead show only such unstable opcodes.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-filter",
      "value_type": "String",
      "takes_value": true,
      "description": "memory, or vice versa. This option allows to either keep all benchmarks, or  filter out (ignore) either all the ones that do involve mem‐ ory (involve instructions that may read or write to memory),  or the opposite, to only keep such benchmarks.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-inconsistencies-output-file",
      "value_type": "File",
      "takes_value": true,
      "description": "found  during  analysis  to this  file. - prints to stdout. By default, this analysis is not run.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-inconsistency-epsilon",
      "value_type": "File",
      "takes_value": true,
      "description": "detection  of  when  the cluster  is  different  from  the  LLVM  schedule profile values (analysis mode).",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-numpoints",
      "value_type": "String",
      "takes_value": true,
      "description": "cluster‐ ing (analysis mode, DBSCAN only).",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-override-benchmark-triple-and-cpu",
      "value_type": "Bool",
      "takes_value": false,
      "description": "benchmarks  for  the triple/CPU  they  were  measured for, but if you want to analyze them for some other combination (specified via  -mtriple/-mcpu), you can pass this flag.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-mode",
      "long": "--benchmark-phase",
      "value_type": "File",
      "takes_value": true,
      "description": "executed and measured, and that requires that we are running on the hardware for which the snippet was  generated,  and  that supports  performance  measurements.  However, it is possible to stop at  some  stage  before  measuring.  Choices  are:  *  pre‐ pare-snippet: Only generate the minimal instruction sequence.  * prepare-and-assemble-snippet:  Same as prepare-snippet, but also dumps an excerpt of the sequence (hex encoded).  * assemble-mea‐ sured-code: Same as prepare-and-assemble-snippet. but also  cre‐ ates  the  full  sequence  that  can  be  dumped to a file using",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--benchmark-repeat-count",
      "value_type": "String",
      "takes_value": true,
      "description": "when  performing  latency measurements. By default, llvm-exegesis will repeat a latency measurement enough times  to balance run-time and noise reduction.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--benchmarks-file",
      "value_type": "String",
      "takes_value": true,
      "description": "to   read  (analysis  mode)  or  write  (latency/uops/in‐ verse_throughput modes) benchmark results. \"-\"  uses  stdin/std‐ out.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--dump-object-to-disk",
      "value_type": "Bool",
      "takes_value": false,
      "description": "*  measure:   Same   as   assemble-mea‐ sured-code, but also runs the measurement.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--execution-mode",
      "value_type": "String",
      "takes_value": true,
      "description": "option specifies what execution mode to use. The inprocess execution mode is the default. The subprocess execution mode al‐ lows for additional features such as memory annotations  but  is currently restricted to X86-64 on Linux.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--help",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--help-list",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--ignore-invalid-sched-class",
      "value_type": "String",
      "takes_value": true,
      "description": "set,  ignore  instructions  that  do  not have a sched class (class idx = 0).",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--loop-body-size",
      "value_type": "Directory",
      "takes_value": true,
      "description": "effective  for  -repetition-mode=[loop|min].   Instead  of looping over the snippet directly, first duplicate  it  so  that the loop body contains at least this many instructions. This po‐ tentially  results in loop body being cached in the CPU Op Cache / Loop Cache, which allows to which may have  higher  throughput than the CPU decoders.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--max-configs-per-opcode",
      "value_type": "String",
      "takes_value": true,
      "description": "the  maximum  configurations  that can be generated for each opcode.  By default this is 1, meaning that we assume  that a  single  measurement is enough to characterize an opcode. This might not be true of all instructions: for example, the  perfor‐ mance  characteristics  of the LEA instruction on X86 depends on the value of assigned registers and immediates. Setting a  value of -max-configs-per-opcode larger than 1 allows llvm-exegesis to explore  more configurations to discover if some register or im‐ mediate assignments lead to different  performance  characteris‐ tics.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--mcpu",
      "value_type": "Number",
      "takes_value": true,
      "description": "counters  for this  CPU.  This  is  useful when creating new sched models (the host CPU is unknown to LLVM).  (-mcpu=help for details)",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--measurements-print-progress",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--mode",
      "value_type": "String",
      "takes_value": true,
      "description": "the  run mode. Note that some modes have additional re‐ quirements and options.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-version",
      "long": "--mtriple",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--num-repetitions",
      "value_type": "Number",
      "takes_value": true,
      "description": "instructions.  Note  that the  actual  repetition count of the snippet will be num-repeti‐ tions/snippet size.  Higher values lead to  more  accurate  mea‐ surements but lengthen the benchmark.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--opcode-index",
      "value_type": "File",
      "takes_value": true,
      "description": "the opcode to measure, by index. Specifying -1 will re‐ sult in measuring every existing opcode. See example 1  for  de‐ tails.   Either  opcode-index, opcode-name or snippets-file must be set.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--opcode-name",
      "value_type": "File",
      "takes_value": true,
      "description": "can  be specified  as a comma-separated list. See example 1 for details. Either opcode-index, opcode-name or snippets-file must be set.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--repetition-mode",
      "value_type": "Number",
      "takes_value": true,
      "description": "duplicate  will  create  a  large, straight line basic block with num-repetitions instructions (re‐ peating  the  snippet  num-repetitions/snippet size times). loop will, optionally, duplicate the snippet until the loop body con‐ tains at least loop-body-size instructions, and  then  wrap  the result in a loop which will execute num-repetitions instructions (thus, again, repeating the snippet num-repetitions/snippet size times).  The  loop mode, especially with loop unrolling tends to better hide the effects of the  CPU  frontend  on  architectures that  cache  decoded  instructions,  but consumes a register for counting iterations. If performing an  analysis  over  many  op‐ codes,  it  may  be best to instead use the min mode, which will run each other mode, and produce the minimal measured result.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--result-aggregation-mode",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--snippets-file",
      "value_type": "File",
      "takes_value": true,
      "description": "example  2  for details.  Either opcode-index, opcode-name or snippets-file must be set.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--use-dummy-perf-counters",
      "value_type": "Bool",
      "takes_value": false,
      "description": "performance  coun‐ ters  and  return a dummy value instead. This can be used to en‐ sure a snippet doesn't crash when hardware performance  counters are unavailable and for debugging llvm-exegesis itself.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--validation-counter",
      "value_type": "Number",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--version",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--x86-disable-upper-sse-registers",
      "value_type": "Bool",
      "takes_value": false,
      "description": "the  upper xmm registers (xmm8-xmm15) forces a longer in‐ struction encoding which may put greater pressure on  the  fron‐ tend fetch and decode stages, potentially reducing the rate that instructions  are  dispatched  to  the  backend, particularly on older hardware. Comparing baseline results with  this  mode  en‐ abled  can help determine the effects of the frontend and can be used to improve latency and throughput estimates.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--x86-lbr-sample-period",
      "value_type": "Number",
      "takes_value": true,
      "description": "the  LBR  sampling period - how many branches before we take a sample.  When a positive value is specified for this  op‐ tion  and when the mode is latency, we will use LBRs for measur‐ ing.  On choosing the \"right\" sampling period, a small value  is preferred,  but  throttling  could  occur if the sampling is too frequent. A prime number should be used  to  avoid  consistently skipping certain blocks.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    }
  ],
  "subcommands": [],
  "positional": [
    {
      "name": "image",
      "value_type": "String",
      "required": false,
      "multiple": false,
      "description": null
    }
  ],
  "source": "Merged",
  "confidence": 0.9,
  "version": null
}