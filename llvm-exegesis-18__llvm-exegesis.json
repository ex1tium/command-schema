{
  "schema_version": "1.0.0",
  "command": "llvm-exegesis-18",
  "description": "LLVM-EXEGESIS(1) LLVM LLVM-EXEGESIS(1)",
  "global_flags": [
    {
      "short": null,
      "long": "---",
      "value_type": "String",
      "takes_value": true,
      "description": "ADD64rr mode:            latency config:          '' cpu_name:        haswell llvm_triple:     x86_64-unknown-linux-gnu num_repetitions: 10000 measurements:",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-clustering",
      "value_type": "File",
      "takes_value": true,
      "description": "the clustering algorithm to use. By default DBSCAN will be used.  Naive clustering algorithm is better for doing further work on the -analysis-inconsistencies-output-file= output, it will create one cluster per opcode, and check that the cluster is stable (all points are neighbours).",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-clustering-epsilon",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-clusters-output-file",
      "value_type": "File",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-display-unstable-clusters",
      "value_type": "Bool",
      "takes_value": false,
      "description": "there  is  more than one benchmark for an opcode, said benchmarks may end up not being clustered into the same cluster if the mea‐ sured performance characteristics are different. by default all such opcodes are filtered out.  This flag will instead show only  such unstable opcodes.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-filter",
      "value_type": "String",
      "takes_value": true,
      "description": "default,  all  benchmark results are analysed, but sometimes it may be useful to only look at those that to not involve memory, or vice versa. This option allows to either keep all benchmarks, or filter out (ignore) either all the ones that do involve  memory  (in‐ volve instructions that may read or write to memory), or the opposite, to only keep such benchmarks.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-inconsistencies-output-file",
      "value_type": "File",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-inconsistency-epsilon",
      "value_type": "File",
      "takes_value": true,
      "description": "LLVM  schedule  profile  values  (analysis mode).",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-numpoints",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--analysis-override-benchmark-triple-and-cpu",
      "value_type": "Bool",
      "takes_value": false,
      "description": "them  for some other combination (specified via -mtriple/-mcpu), you can pass this flag.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-mode",
      "long": "--benchmark-phase",
      "value_type": "File",
      "takes_value": true,
      "description": "are  running  on the hardware for which the snippet was generated, and that supports performance measurements.  However, it is possible to stop at some stage  before measuring. Choices are: * prepare-snippet: Only generate the minimal instruction sequence.  * prepare-and-assemble-snip‐ pet: Same as prepare-snippet, but also dumps an excerpt of the  sequence  (hex  encoded).   *  assemble-measured-code:  Same  as  pre‐ pare-and-assemble-snippet.  but  also  creates the full sequence that can be dumped to a file using --dump-object-to-disk.  * measure: Same as assemble-measured-code, but also runs the measurement.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--benchmark-repeat-count",
      "value_type": "String",
      "takes_value": true,
      "description": "the  measurement  when  performing  latency  measurements.  By  default, llvm-exegesis will repeat a latency measurement enough times to balance run-time and noise reduction.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--benchmarks-file",
      "value_type": "File",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--dump-object-to-disk",
      "value_type": "File",
      "takes_value": true,
      "description": "llvm-exegesis will dump the generated code to a temporary file to enable code inspection. Disabled by default.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--execution-mode",
      "value_type": "String",
      "takes_value": true,
      "description": "option  specifies  what execution mode to use. The inprocess execution mode is the default. The subprocess execution mode allows for additional features such as memory annotations but is currently restricted to X86-64 on Linux.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--help",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--help-list",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--ignore-invalid-sched-class",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-repetition-mode",
      "long": "--loop-body-size",
      "value_type": "Directory",
      "takes_value": true,
      "description": "Instead of looping over the snippet directly, first duplicate it  so  that  the  loop body  contains  at  least this many instructions. This potentially results in loop body being cached in the CPU Op Cache / Loop Cache, which allows to which may have higher throughput than the CPU decoders.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--max-configs-per-opcode",
      "value_type": "String",
      "takes_value": true,
      "description": "By default this is 1, meaning that we assume that a  single measurement is enough to characterize an opcode. This might not be true of all instructions: for example, the performance characteris‐ tics  of the LEA instruction on X86 depends on the value of assigned registers and immediates. Setting a value of -max-configs-per-op‐ code larger than 1 allows llvm-exegesis to explore more configurations to discover if some register or immediate assignments  lead  to different performance characteristics.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--mcpu",
      "value_type": "Number",
      "takes_value": true,
      "description": "set,  measure the cpu characteristics using the counters for this CPU. This is useful when creating new sched models (the host CPU is unknown to LLVM).  (-mcpu=help for details)",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--measurements-print-progress",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--mode",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-version",
      "long": "--mtriple",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--num-repetitions",
      "value_type": "String",
      "takes_value": true,
      "description": "Higher values lead to more accurate measurements but lengthen the benchmark.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-1",
      "long": "--opcode-index",
      "value_type": "File",
      "takes_value": true,
      "description": "Ei‐ ther opcode-index, opcode-name or snippets-file must be set.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--opcode-name",
      "value_type": "File",
      "takes_value": true,
      "description": "Either opcode-index, opcode-name or snippets-file must be set.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--repetition-mode",
      "value_type": "Number",
      "takes_value": true,
      "description": "until  the  loop  body  contains  at  least loop-body-size  instructions, and then wrap the result in a loop which will execute num-repetitions instructions (thus, again, repeat‐ ing the snippet num-repetitions/snippet size times). The loop mode, especially with loop unrolling tends to better hide the effects of the CPU frontend on architectures that cache decoded instructions, but consumes a register for counting iterations. If  performing  an analysis  over  many opcodes, it may be best to instead use the min mode, which will run each other mode, and produce the minimal mea‐ sured result.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--result-aggregation-mode",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--snippets-file",
      "value_type": "File",
      "takes_value": true,
      "description": "Either opcode-index, opcode-name or snippets-file must be set.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--use-dummy-perf-counters",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--validation-counter",
      "value_type": "Number",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--version",
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--x86-disable-upper-sse-registers",
      "value_type": "Bool",
      "takes_value": false,
      "description": "frontend  fetch and decode stages, potentially reducing the rate that instructions are dispatched to the backend, particularly on older hardware. Com‐ paring  baseline  results with this mode enabled can help determine the effects of the frontend and can be used to improve latency and throughput estimates.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--x86-lbr-sample-period",
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    }
  ],
  "subcommands": [],
  "positional": [
    {
      "name": "LBR.",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    },
    {
      "name": "RDTSC",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    },
    {
      "name": "X86",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    },
    {
      "name": "x86-lbr-sample-period",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    }
  ],
  "source": "Merged",
  "confidence": 0.9,
  "version": null
}