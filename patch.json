{
  "schema_version": "1.0.0",
  "command": "patch",
  "description": "patch - apply a diff file to an original",
  "global_flags": [
    {
      "short": "-b",
      "long": "--backup",
      "value_type": "Bool",
      "takes_value": false,
      "description": "or --backup Make backup files. That is, when patching a file, rename or copy the original instead of removing it. See the -V or --version-con‐ trol option for details about how backup file names are determined.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--backup-if-mismatch",
      "value_type": "Bool",
      "takes_value": false,
      "description": "and  if backups  are  not  otherwise  requested.  This is the default unless patch is conforming to POSIX.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-t",
      "long": "--batch",
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --batch Suppress questions like -f, but  make  some  different  assumptions: skip  patches  whose  headers do not contain file names (the same as",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--binary",
      "value_type": "File",
      "takes_value": true,
      "description": "mode,  except  for  standard  output  and /dev/tty.  When reading, disable the heuristic for transforming CRLF line  endings  into LF line endings.  This option is needed on POSIX systems when applying patches generated on non-POSIX systems to non- POSIX files.  (On POSIX systems, file reads and writes never  trans‐ form  line  endings.  On Windows, reads and writes do transform line endings by default, and patches should be generated by diff --binary when line endings are significant.)",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-c",
      "long": "--context",
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --context Interpret the patch file as a ordinary context diff.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--dry-run",
      "value_type": "Bool",
      "takes_value": false,
      "description": "the results of applying the patches without actually changing any files.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-e",
      "long": "--ed",
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --ed Interpret the patch file as an ed script.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--follow-symlinks",
      "value_type": "Bool",
      "takes_value": false,
      "description": "looking  for input files, follow symbolic links.  Replaces the symbolic links, instead of modifying the files  the  symbolic  links point to.  Git-style patches to symbolic links will no longer apply. This  option  exists  for backwards compatibility with previous ver‐ sions of patch; its use is discouraged.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-f",
      "long": "--force",
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --force Assume  that  the user knows exactly what he or she is doing, and do not ask any questions.  Skip patches whose headers do not say  which file  is  to be patched; patch files even though they have the wrong version for the Prereq: line in the patch; and assume  that  patches are  not reversed even if they look like they are.  This option does not suppress commentary; use -s for that.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-N",
      "long": "--forward",
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --forward When a patch does not apply, patch usually checks if the patch looks like  it  has  been  applied  already by trying to reverse-apply the first hunk.  The --forward option prevents that.  See also -R.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-g",
      "long": "--get",
      "value_type": "File",
      "takes_value": true,
      "description": "or --get=num This option controls patch's actions when a file is under RCS or SCCS control, and does not exist or is read-only and matches the de‐ fault version, or when a file is under ClearCase or Perforce control and does not exist. If num is positive, patch gets (or checks out) the file from the revision control system; if zero, patch ignores RCS, ClearCase, Perforce, and SCCS and does not get the file; and if negative, patch asks the user whether to get the file. The default value of this option is given by the value of the PATCH_GET environ‐ ment variable if it is set; if not, the default value is zero.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--help",
      "value_type": "Bool",
      "takes_value": false,
      "description": "Output this help.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-l",
      "long": "--ignore-whitespace",
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --ignore-whitespace Match patterns loosely, in case tabs or spaces have been  munged  in your  files.   Any  sequence of one or more blanks in the patch file matches any sequence in the original file, and sequences  of  blanks at  the  ends  of  lines  are ignored.  Normal characters must still match exactly.  Each line of the context must still match a line  in the original file.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--merge",
      "value_type": "File",
      "takes_value": true,
      "description": "a  patch  file into the original files similar to diff3(1) or merge(1).  If a conflict is  found,  patch  outputs  a  warning  and brackets  the  conflict  with  <<<<<<< and >>>>>>> lines.  A typical conflict will look like this:",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--no-backup-if-mismatch",
      "value_type": "Bool",
      "takes_value": false,
      "description": "file  exactly and  if backups are not otherwise requested.  This is the default if patch is conforming to POSIX.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-n",
      "long": "--normal",
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --normal Interpret the patch file as a normal diff.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--posix",
      "value_type": "String",
      "takes_value": true,
      "description": "Conform to the POSIX standard.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-s",
      "long": "--quiet",
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --silent  or  --quiet Work silently, unless an error occurs.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--quoting-style",
      "value_type": "String",
      "takes_value": true,
      "description": "The word should be one of the following:",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--read-only",
      "value_type": "File",
      "takes_value": true,
      "description": "as  requested when trying to modify a read-only file: ignore the potential problem, warn about it (the default), or fail.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--reject-format",
      "value_type": "String",
      "takes_value": true,
      "description": "Without this option, rejected hunks come out in unified diff format if the input patch was of that format, otherwise in  ordinary context diff form.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-E",
      "long": "--remove-empty-files",
      "value_type": "File",
      "takes_value": true,
      "description": "or  --remove-empty-files Remove output files that are empty after the patches have  been  ap‐ plied.  Normally this option is unnecessary, since patch can examine the time stamps on the header to determine whether a file should ex‐ ist  after patching.  However, if the input is not a context diff or if patch is conforming to POSIX, patch does not remove empty patched files unless this option is given.  When patch removes  a  file,  it also attempts to remove any empty ancestor directories.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-R",
      "long": "--reverse",
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --reverse Assume  that  this  patch  was  created  with  the old and new files swapped.  (Yes, I'm afraid that does happen occasionally, human  na‐ ture being what it is.)  patch attempts to swap each hunk around be‐ fore  applying  it.  Rejects come out in the swapped format.  The -R option does not work with ed diff scripts because there is too  lit‐ tle information to reconstruct the reverse operation.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-T",
      "long": "--set-time",
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --set-time Set the modification and access times of  patched  files  from  time stamps  given in context diff headers.  Unless specified in the time stamps, assume that the context diff headers use local time.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-Z",
      "long": "--set-utc",
      "value_type": "File",
      "takes_value": true,
      "description": "or  --set-utc Set the modification and access times of  patched  files  from  time stamps  given  in context diff headers. Unless specified in the time stamps, assume that the context diff headers use Coordinated Univer‐ sal Time (UTC, often known as GMT).  Also see the -T  or  --set-time option.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-u",
      "long": "--unified",
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --unified Interpret the patch file as a unified context diff.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": null,
      "long": "--verbose",
      "value_type": "Bool",
      "takes_value": false,
      "description": "Output extra information about the work being done.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-v",
      "long": "--version",
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --version Print out patch's revision header and patch level, and exit.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-B",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --prefix=pref Use the simple method to determine backup file  names  (see  the  -V method  or  --version-control  method  option), and append pref to a file name when generating its backup file name.  For  example,  with",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-D",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --ifdef=define Use the #ifdef ... #endif construct to mark changes, with define  as the differentiating symbol.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-F",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --fuzz=num Set the maximum fuzz factor.  This option only applies to diffs that have context, and causes patch to ignore up to that  many  lines  of context in looking for places to install a hunk.  Note that a larger fuzz  factor increases the odds of a faulty patch.  The default fuzz factor is 2.  A fuzz factor greater than or equal to the  number  of lines of context in the context diff, ordinarily 3, ignores all con‐ text.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-V",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "or  --version-control=method Use  method  to determine backup file names.  The method can also be given by the PATCH_VERSION_CONTROL (or, if that's not set, the  VER‐ SION_CONTROL)  environment variable, which is overridden by this op‐ tion.  The method does not affect whether backup files are made;  it affects only the names of any backup files that are made.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-Y",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --basename-prefix=pref Use  the  simple  method  to determine backup file names (see the -V method or --version-control method option), and prefix pref  to  the basename  of  a file name when generating its backup file name.  For example,  with  -Y .del/   the   simple   backup   file   name   for src/patch/util.c is src/patch/.del/util.c.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-d",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --directory=dir Change to the directory dir immediately, before doing anything else.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-i",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --input=patchfile Read  the  patch from patchfile.  If patchfile is -, read from stan‐ dard input, the default.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-m",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-o",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --output=outfile Send output to outfile instead of patching files in place.   Do  not use  this option if outfile is one of the files to be patched.  When outfile is -, send output to standard output, and send any  messages that would usually go to standard output to standard error.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-p",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-pnum",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --strip=num Strip  the  smallest prefix containing num leading slashes from each file name found in the patch file.  A sequence of one or more  adja‐ cent  slashes  is counted as a single slash.  This controls how file names found in the patch file are treated, in  case  you  keep  your files  in  a  different  directory  than the person who sent out the patch.  For example, supposing the file name in the patch file was",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-r",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --reject-file=rejectfile Put rejects into rejectfile instead of the default .rej file.   When rejectfile is -, discard rejects.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-x",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --debug=num Set internal debugging flags of interest only to patch patchers.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-z",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "or  --suffix=suffix Use  the  simple  method  to determine backup file names (see the -V method or --version-control method option), and use  suffix  as  the suffix.    For   example,   with  -z -  the  backup  file  name  for src/patch/util.c is src/patch/util.c-.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    }
  ],
  "subcommands": [],
  "positional": [
    {
      "name": "originalfile",
      "value_type": "File",
      "required": false,
      "multiple": false,
      "description": null
    },
    {
      "name": "patchfile",
      "value_type": "File",
      "required": false,
      "multiple": false,
      "description": null
    }
  ],
  "source": "Merged",
  "confidence": 0.9,
  "version": null
}