{
  "schema_version": "1.0.0",
  "command": "find",
  "description": "find - search for files in a directory hierarchy",
  "global_flags": [
    {
      "short": "-help",
      "long": "--help",
      "value_type": "Bool",
      "takes_value": false,
      "description": "display this help and exit",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-version",
      "long": "--version",
      "value_type": "Bool",
      "takes_value": false,
      "description": "output version information and exit",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-D",
      "long": null,
      "value_type": "String",
      "takes_value": true,
      "description": "The  list  of  debug options  should  be  comma separated.  Compatibility of the debug options is not guaranteed between releases of findutils.  For a com‐ plete list of valid debug options, see the output of find -D help.  Valid debug options include",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-H",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "Do not follow symbolic links, except while processing the command line arguments.  When find  examines  or  prints  information  about files,  the  information used shall be taken from the properties of the symbolic link itself.  The only exception to this behaviour is when a file specified on the command line is a symbolic link, and the link can be resolved.  For that situation, the information  used is  taken  from whatever the link points to (that is, the link is followed).  The information about the link itself is used as a fall‐ back if the file pointed to by the symbolic link cannot be examined.  If -H is in effect and one of the paths specified on the command line is a symbolic link to a directory, the contents of that directory will be examined (though of course  -maxdepth 0  would  prevent this).",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-L",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "Follow  symbolic links.  When find examines or prints information about files, the information used shall be taken from the properties of the file to which the link points, not from the link itself (unless it is a broken symbolic link or find is unable to  examine  the file to which the link points).  Use of this option implies -noleaf.  If you later use the -P option, -noleaf will still be in effect. If -L is in effect and find discovers a symbolic link to a subdirectory during its search, the subdirectory pointed to by the symbolic link will be searched.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-O",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-Olevel",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "The find program reorders tests to speed up execution while preserving the overall effect; that is, pred‐ icates with side effects are not reordered relative to each other.  The optimisations performed at each optimisation level are as fol‐ lows.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-P",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "Never follow symbolic links.  This is the default behaviour.  When find examines or prints information about files, and the file is  a symbolic link, the information used shall be taken from the properties of the symbolic link itself.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-amin",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-anewer",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "If  refer‐ ence  is  a  symbolic link and the -H option or the -L option is in effect, then the time of the last data modification of the file it points to is always used.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-atime",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "When find figures out how many 24-hour periods  ago  the  file was last accessed, any fractional part is ignored, so to match -atime +1, a file has to have been accessed at least two days ago.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-cmin",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-cnewer",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "of  the last status change of the current file is more recent than that of the last data modification of the reference file.  If reference is a symbolic link and the -H option or the -L option is in effect, then the time of the last data modification of the  file it points to is always used.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-context",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-ctime",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "See the comments for -atime to understand how rounding affects the interpretation of file status change times.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-d",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "A synonym for -depth, for compatibility with FreeBSD, NetBSD, MacOS X and OpenBSD.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-daystart",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "ago.   This option only affects tests which appear later on the command line.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-delete",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "If the removal failed, an error message is issued and find's exit status will be nonzero (when it eventually exits).",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-depth",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "The -delete action also implies -depth.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-e",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-empty",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-exec",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "command; true if 0 status is returned.  All following arguments to find are taken to be arguments to the command until an ar‐ gument consisting of `;' is encountered.  The string `{}' is replaced by the current file name being processed everywhere it occurs in the arguments to the command, not just in arguments where it is alone, as in some versions of find.  Both of these constructions might need to be escaped (with a `\\') or quoted to protect them from expansion by the shell.  See the EXAMPLES section for examples  of  the use of the -exec option.  The specified command is run once for each matched file.  The command is executed in the starting directory. There are unavoidable security problems surrounding use of the -exec action; you should use the -execdir option instead.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-execdir",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-executable",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "files  which are executable and directories which are searchable (in a file name resolution sense) by the current user.  This takes into account access control lists and other permissions artefacts which the -perm test ignores.  This test makes use of the  ac‐ cess(2)  system  call,  and so can be fooled by NFS servers which do UID mapping (or root-squashing), since many systems implement ac‐ cess(2) in the client's kernel and so cannot make use of the UID mapping information held on the server.  Because this test  is  based only  on  the result of the access(2) system call, there is no guarantee that a file for which this test succeeds can actually be exe‐ cuted.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-false",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-fls",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "like  -ls  but write to file like -fprint.  The output file is always created, even if the predicate is never matched.  See the UNUSUAL FILENAMES section for information about how unusual characters in filenames are handled.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-follow",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "use  the  -L  option instead.  Dereference symbolic links.  Implies -noleaf.  The -follow option affects only those tests which appear after it on the command line.  Unless the -H or -L option has been specified, the position of the -follow option  changes the  behaviour  of  the  -newer predicate; any files listed as the argument of -newer will be dereferenced if they are symbolic links. The same consideration applies to -newerXY, -anewer and -cnewer.  Similarly, the -type predicate will always match against the type of the file that a symbolic link points to rather than the link itself.  Using -follow causes the -lname and -ilname predicates always to return false.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-fprint",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "If file does not exist when find is run, it is created; if it does exist, it is  trun‐ cated.  The file names /dev/stdout and /dev/stderr are handled specially; they refer to the standard output and standard error output, respectively.   The  output file is always created, even if the predicate is never matched.  See the UNUSUAL FILENAMES section for in‐ formation about how unusual characters in filenames are handled.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-fprint0",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "The output file is always created, even if the predicate is  never  matched.   See the UNUSUAL FILENAMES section for information about how unusual characters in filenames are handled.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-fprintf",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "like  -printf  but write to file like -fprint.  The output file is always created, even if the predicate is never matched.  See the UNUSUAL FILENAMES section for information about how unusual characters in filenames are handled.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-fstype",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "The valid filesystem types vary among  different  versions  of  Unix;  an  incomplete  list  of filesystem  types  that  are  accepted  on  some version of Unix or another is: ufs, 4.2, 4.3, nfs, tmp, mfs, S51K, S52K.  You can use",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-gid",
      "long": null,
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-group",
      "long": null,
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-ilname",
      "long": null,
      "value_type": "String",
      "takes_value": true,
      "description": "If the -L option or the -follow option is in effect, this test returns  false  unless the symbolic link is broken.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-iname",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "-name,  but  the match is case insensitive.  For example, the patterns `fo*' and `F??' match the file names `Foo', `FOO', `foo', `fOo', etc.  The pattern `*foo*` will also match a file called '.foobar'.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-inum",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "It is normally easier to use the -samefile test instead.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-ipath",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "but the match is case insensitive.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-iregex",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-iwholename",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "This alternative is less portable than -ipath.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-l",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-links",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-lname",
      "long": null,
      "value_type": "String",
      "takes_value": true,
      "description": "The metacharacters do not treat `/' or `.' specially.  If the  -L option or the -follow option is in effect, this test returns false unless the symbolic link is broken.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-ls",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "True; list current file in ls -dils format on standard output.  The block counts are of 1 KB blocks, unless the  environment  variable POSIXLY_CORRECT  is  set, in which case 512-byte blocks are used.  See the UNUSUAL FILENAMES section for information about how unusual characters in filenames are handled.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-maxdepth",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "at  most levels (a non-negative integer) levels of directories below the starting-points.  Using -maxdepth 0 means only apply the tests and actions to the starting-points themselves.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-mindepth",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "Using -mindepth 1 means process all files  ex‐ cept the starting-points.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-mmin",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-mount",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "An alternate name for -xdev, for compatibility with some other versions of find.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-mtime",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "data was last modified less than, more than or exactly n*24 hours ago.  See the comments for -atime to understand how rounding affects the interpretation of file modification times.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-n",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "for less than n,",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-name",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "Because the leading directories  are removed,  the  file  names considered for a match with -name will never include a slash, so `-name a/b' will never match anything (you probably need to use -path instead).  A warning is issued if you try to do this, unless the environment  variable  POSIXLY_CORRECT  is set.  The metacharacters (`*', `?', and `[]') match a `.' at the start of the base name (this is a change in findutils-4.2.2; see sec‐ tion  STANDARDS  CONFORMANCE  below).  To ignore a directory and the files under it, use -prune rather than checking every file in the tree; see an example in the description of that action.  Braces are not recognised as being special, despite the fact that some shells including Bash imbue braces with a special meaning in shell patterns.  The filename matching is performed with  the  use  of  the  fn‐ match(3) library function.  Don't forget to enclose the pattern in quotes in order to protect it from expansion by the shell.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-newer",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "of  the last data modification of the current file is more recent than that of the last data modification of the reference file. If reference is a symbolic link and the -H option or the -L option is in effect, then the time of the last data  modification  of  the file it points to is always used.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-newerXY",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "if timestamp X of the file being considered is newer than timestamp Y of the file reference.  The letters X and Y can be any of the following letters:",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-nogroup",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-noleaf",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "not  optimize  by assuming that directories contain 2 fewer subdirectories than their hard link count.  This option is needed when searching filesystems that do not follow the Unix directory-link convention, such as CD-ROM or MS-DOS filesystems or AFS volume  mount points.   Each  directory on a normal Unix filesystem has at least 2 hard links: its name and its `.' entry.  Additionally, its subdi‐ rectories (if any) each have a `..' entry linked to that directory.  When find is examining a directory, after it has statted 2  fewer subdirectories  than  the  directory's  link count, it knows that the rest of the entries in the directory are non-directories (`leaf' files in the directory tree).  If only the files' names need to be examined, there is no need to stat them; this gives  a  significant increase in search speed.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-not",
      "long": null,
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-nouser",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-ok",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "If the user agrees, run the command.  Otherwise just return false.  If the  command  is  run,  its standard input is redirected from /dev/null.  This action may not be specified together with the -files0-from option.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-okdir",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "If the user does not agree, just return false.  If  the  command  is run, its standard input is redirected from /dev/null.  This action may not be specified together with the -files0-from option.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-path",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "The metacharacters do not treat `/' or `.' specially; so, for example, find . -path \"./sr*sc\" will  print  an  entry  for  a  directory called ./src/misc (if one exists).  To ignore a whole directory tree, use -prune rather than checking every file in the tree.  Note that the pattern match test applies to the whole file name, starting  from  one  of  the  start points  named  on the command line.  It would only make sense to use an absolute path name here if the relevant start point is also an absolute path.  This means that this command will never match anything: find bar -path /foo/bar/myfile -print Find compares the -path argument with the concatenation of a directory name and the base name of the file it's examining.   Since  the concatenation  will  never end with a slash, -path arguments ending in a slash will match nothing (except perhaps a start point speci‐ fied on the command line).  The predicate -path is also supported by HP-UX find and is part of the POSIX 2008 standard.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-perm",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "Since an exact match is required, if you want to use this form for  sym‐ bolic modes, you may have to specify a rather complex mode string.  For example `-perm g=w' will only match files which have mode 0020 (that  is,  ones for which group write permission is the only permission set).  It is more likely that you will want to use the `/' or `-' forms, for example `-perm -g=w', which matches any file with group write permission.  See the EXAMPLES section for some  illustra‐ tive examples.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-print",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "print the full file name on the standard output, followed by a newline.  If you are piping the output of find into another pro‐ gram and there is the faintest possibility that the files which you are searching for might contain a newline, then you  should  seri‐ ously  consider using the -print0 option instead of -print.  See the UNUSUAL FILENAMES section for information about how unusual char‐ acters in filenames are handled.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-print0",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "the  newline  character  that  -print uses).   This  allows  file  names  that  contain  newlines or other types of white space to be correctly interpreted by programs that process the find output.  This option corresponds to the -0 option of xargs.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-printf",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-prune",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "if  the  file  is a directory, do not descend into it.  If -depth is given, then -prune has no effect.  Because -delete implies",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-quit",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "Exit  immediately (with return value zero if no errors have occurred).  This is different to -prune because -prune only applies to the contents of pruned directories, while -quit simply makes find stop immediately.  No child processes will be left running.  Any command lines which have been built by -exec ... + or -execdir ... + are invoked before the program is exited.  After -quit  is  executed,  no more  files  specified  on  the  command  line  will be processed.  For example, `find /tmp/foo /tmp/bar -print -quit` will print only `/tmp/foo`. One common use of -quit is to stop searching the file system once we have found what we want.  For example, if we want to find just  a single file we can do this: find / -name needle -print -quit",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-readable",
      "long": null,
      "value_type": "Number",
      "takes_value": true,
      "description": "This takes into account access control lists and  other  permissions  artefacts which the -perm test ignores.  This test makes use of the access(2) system call, and so can be fooled by NFS servers which do UID map‐ ping  (or root-squashing), since many systems implement access(2) in the client's kernel and so cannot make use of the UID mapping in‐ formation held on the server.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-regex",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "This is a match on the whole path, not a search.  For example, to match  a  file  named ./fubar3, you can use the regular expression `.*bar.' or `.*b.*3', but not `f.*r3'.  The regular expressions understood by find are by default Emacs Regular Expressions (except that `.' matches newline), but this can be changed with the -regextype option.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-regextype",
      "long": null,
      "value_type": "String",
      "takes_value": true,
      "description": "To see which reg‐ ular expression types are known, use -regextype help.  The Texinfo documentation (see SEE ALSO) explains the meaning  of  and  differ‐ ences between the various types of regular expression.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-samefile",
      "long": null,
      "value_type": "String",
      "takes_value": true,
      "description": "When -L is in effect, this can include symbolic links.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-size",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "The following suffixes can be used:",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-true",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "Always true.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-type",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-uid",
      "long": null,
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-used",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-user",
      "long": null,
      "value_type": "String",
      "takes_value": true,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-v",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": null,
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-warn",
      "long": null,
      "value_type": "Directory",
      "takes_value": true,
      "description": "These warnings apply only to the command line usage, not to any conditions that find might encounter when  it searches directories.  The default behaviour corresponds to -warn if standard input is a tty, and to -nowarn otherwise.  If a warning message relating to command-line usage is produced, the exit status of find is not affected.  If the POSIXLY_CORRECT  environ‐ ment variable is set, and -warn is also used, it is not specified which, if any, warnings will be active.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-wholename",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "This alternative is less portable than -path.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-writable",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "files  which  are writable by the current user.  This takes into account access control lists and other permissions artefacts which the -perm test ignores.  This test makes use of the access(2) system call, and so can be fooled by NFS servers which do UID map‐ ping (or root-squashing), since many systems implement access(2) in the client's kernel and so cannot make use of the UID mapping  in‐ formation held on the server.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-xdev",
      "long": null,
      "value_type": "Bool",
      "takes_value": false,
      "description": "Don't descend directories on other filesystems.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    },
    {
      "short": "-xtype",
      "long": null,
      "value_type": "File",
      "takes_value": true,
      "description": "For symbolic links: if the -H or -P option was specified, true if the file is a link  to  a  file of type c; if the -L option has been given, true if c is `l'.  In other words, for symbolic links, -xtype checks the type of the file that -type does not check.",
      "multiple": false,
      "conflicts_with": [],
      "requires": []
    }
  ],
  "subcommands": [],
  "positional": [
    {
      "name": "debugopts",
      "value_type": "String",
      "required": true,
      "multiple": false,
      "description": null
    },
    {
      "name": "expression",
      "value_type": "String",
      "required": false,
      "multiple": false,
      "description": null
    },
    {
      "name": "starting-point",
      "value_type": "String",
      "required": false,
      "multiple": true,
      "description": null
    }
  ],
  "source": "Merged",
  "confidence": 0.9,
  "version": null
}